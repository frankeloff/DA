\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
% \usepackage{array}

\usepackage{listings}
\usepackage{xcolor}

\usepackage{pgfplots}
% \pgfplotsset{compat=1.9}


% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,3 по курсу дискрeтного анализа: Сбаласированные деревья}

Выполнил студент группы М8О-208Б-20 МАИ \textit{Зинин Владислав}.

\subsection*{Условие}

% Кратко описывается задача: 
Для реализации словаря из предыдущей лабораторной работы,
необходимо провести исследование скорости выполнения и потребления
оперативной памяти. В случае выявления ошибок или явных недочётов,
требуется их исправить.

\subsection*{gprof}

\subsubsection*{Основная информация}

Утилита gprof позволяет измерить время работы всех функций, методов и операторов
программы, количество их вызовов и долю от общего времени работы программы в 
процентах.

\subsubsection*{Команды для работы с утилитой}

Для работы с утилитой необходимо скомпилировать нашу программу с ключом $-pg$:

\begin{lstlisting}
    g++ -pg main.cpp
\end{lstlisting}

Затем мы должны запустить программу, которая принимает на вход файл с 100000 тестами

\begin{lstlisting}
    ./a.out
\end{lstlisting}

После выполнения данной команды заметим, что появился файл gmon.out, в котором содержится вся информация, 
необходимая утилите Gprof для вывода информации о профилировании в читаемом человеком формате. 
Далее мы должны воспользоваться gprof следующим образом (вывод утилиты будет находится в файле imput.txt):

\begin{lstlisting}
    gprof a.out gmon.out > input.txt
\end{lstlisting}

Таким образом, выполнив 3 простые команды, мы получили текстовый файл с подробной 
информацией о времени работы и вызовах всех функций и операторов, которые 
использовались в программе.

\subsubsection*{Результат работы утилиты}

Ниже приведена таблица с результатами утилиты gprof, которые находятся в файле input.txt:

\begin{tabular}{ | c | c | c | c | }
    \hline
        \% time & self seconds & calls & name \\ \hline
        24.17 & 0.07 & 100000 & ToLower(char*) \\
        17.26 & 0.05 & 527381 & SearchInCurrentNode(BNode*, char*) \\
        13.81 & 0.04 & 9584123 & Min(int, int) \\
        10.36 & 0.03 & 599261 & operator<(map&, map&) \\
        10.36 & 0.03 & 100000 & SearchNode(BNode*, char*, BNode*&, int&) \\
        10.36 & 0.03 & 33045 & InsertNonfull(BNode*, map&) \\
        6.91 & 0.02 & 1443372 & operator<(map&, char*) \\
        3.45 & 0.01 & 1443372 & BTree::Search(char*) \\
    \hline
\end{tabular}


Все остальные функции, отсутствующие в таблице, работали примерно 0 секунд.
По результатам утилиты мы видим, что большая часть работы времени программы тратится на
операцию переноса строки в нижний регистр. Возможно, это связано с тем, что каждая строка,
поданая на вход, проходит через эту функцию, которая в свою очередь с помощью одного прохода по строке
переводит её в нижний регистр.

Также давайте посмотрим на то, как меняется время работы функции SearchInCurrentNode от общего числа работы всех функций с увеличение
характеристического числа t:

Таблица для характеристического числа t=5:

\begin{tabular}{ | c | c | c | c | }
    \hline
        \% time & self seconds & calls & name \\ \hline
        33.13 & 0.16 & 6577020 & SearchInCurrentNode(BNode*, char*) \\
        19.88 & 0.28 & 1000000 & ToLower(char*) \\
        13.25 & 0.39 & 17396217 & operator<(map&, char*) \\
        11.78  & 0.03 & 1000000 & SearchNode(BNode*, char*, BNode*&, int&) \\
    \hline
\end{tabular}

Таблица для характеристического числа t=64:

\begin{tabular}{ | c | c | c | c | }
    \hline
        \% time & self seconds & calls & name \\ \hline
        27.24 & 0.37 & 331613 & InsertNonfull(BNode*, map&) \\
        17.67 & 0.24 & 34213186 & operator<(map&, map&) \\
        17.48 & 0.39 & 1000000 & ToLower(char*) \\
        14.30 & 0.03 & 17070516 & operator<(map&, char*) \\
        7.95 & 0.03 & 2969138 & SearchInCurrentNode(BNode*, char*) \\
    \hline
\end{tabular}

В результате проведенного исследования можно сделать вывод, что чем больше у нас характеристическое число t,
тем меньший объем времени от общего количества занимает функция  SearchInCurrentNode. Обусловленно это тем, что характеристическое число
влияет на количество возможных пар ключ-значение в каждой ноде, а сложность поиска SearchInCurrentNode - логарифм (бинарный поиск). А мы знаем, что
худшее время бинарный поиск показывает на очень малых значениях. С увеличением числа t мы увеличили максимально возможное количество пар ключ-значение в ноде,
следовательно, обезопасили себя от худшего случая бинарного поиска, и, как следствие, работа функции SearchInCurrentNode от общего числа работы программы сократилась
с 33 процентов до 8.

\subsection*{valgrind}

Valgrind хорошо известен как мощное средство поиска ошибок работы с памятью. Но кроме этого, в его 
составе имеется некоторое количество дополнительных утилит, предназначенных для профилирования программ, анализа потребления памяти 
и поиска ошибок связанных с синхронизацией в многопоточных программах. Чтобы проверить нашу программу на утечки, выполнил следующую команду:

\begin{lstlisting}
    valgrind --leak-check=full ./a.out > valgrind.txt
\end{lstlisting}

В результате выполнения этой команды получаем следующее сообщение:

\begin{lstlisting}
    ==2465== Memcheck, a memory error detector
    ==2465== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
    ==2465== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
    ==2465== Command: ./a.out
    ==2465== 
    ==2465== 
    ==2465== HEAP SUMMARY:
    ==2465==     in use at exit: 0 bytes in 0 blocks
    ==2465==   total heap usage: 41,124 allocs, 41,124 frees, 11,651,113 bytes allocated
    ==2465== 
    ==2465== All heap blocks were freed -- no leaks are possible
    ==2465== 
    ==2465== For lists of detected and suppressed errors, rerun with: -s
    ==2465== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\end{lstlisting}

В результате с помощью Valgrind ошибок обнаружено не было.

\subsection*{Выводы}

В результате выполнения лабораторной работы, я познакомился с полезной утилитой gprof, рассчитывающей количество времени, 
которое проходит в процессе исполнения каждой из процедур или функций, а также
закрепил навыки работы с valgrind.

\end{document}