\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{pgfplots}

\begin{document}

    \section*{Курсовой проект\, Алгоритм LZ77}

    Выполнил студент группы М8О-308Б-20 МАИ \textit{Зинин Владислав}.

    \subsection*{Условие}
 
    \begin{enumerate}
    \item Выберите один из предложенных алгоритмов и реализуйте его согласно заданию.
    \item \textbf{Вариант LZ77} Реализуйте алгоритм LZ77. Без окна, поиск производится по всему просмотренному ранее тексту.
    \end{enumerate}

    \subsection*{Метод решения}

    Данный алгоритм состоит из двух частей: кодировка и декодировка.
    1. Метод решения кодировки. У меня есть переменная $global\_pos$, отвечающая за полное прохождение заданного слова. Вся суть решения заключается в том,
    что я прохожусь по элементам и ищу наивным способом схожую подпоследовательность, считая при этом необходимый отступ от текущей позиции до начала совпадения ($shift$),
    далее считаю размер схожей подпоследовательности ($max\_size$). Важно отметить, что из всех подпоследоватеьностей я беру самую большую, а если есть одинаковые по величине, то самую правую
    для того, чтобы наш отступ ($shift$) был меньше. Ну и после заполнения всех необходимых переменных, я собираю следующую тройку: <$shift$, $max\_size$, $last$>. $last$ - следующий элемент нашего слова после последовательности, которая совпала. Если
    следующего элемента нет, то я ставлю туда эпсилон ($E$). После всего этого вывожу последовательно тройки.

    2. Метод решения декодирования. Поступающие данные считываются в массив троек, после чего я создаю пустую строку, которую впоследствии буду заполнять. Начинаю проход
    по каждой тройки и смотрю на $shift$. Если он равен 0, то я просто добавляю добавляю $last$ в нашу строку. Если же он не равен 0, то я делаю смещение в нашей строке и начинаю
    циклом от 0 до $size$ добавлять элементы в конец строки начиная с текущей позиции - $shift$. После я добавляю $last$ в строку. Все добавления в строку происходят в конец. Таким образом,
    наша итоговая строка и будет ответом.

    \subsection*{Описание программы}

    Программа состоит из одного файла.

    \subsection*{Дневник отладки}

    \begin{enumerate}
    \item Программа была выполнена с первого раза.
    \end{enumerate}

    \subsection*{Тест производительности}

    Ниже приведен тест времени работы алгоритма кодировки. По оси $X$ — количество 
    букв в слове, по оси $Y$ — время выполнения алгоритма в мс (меньше 
    — лучше).
    
    \begin{tikzpicture}
        \begin{axis} [
            ymin = 0
        ]
        \addplot coordinates {
            (1000,32) (50000,1001) (100000,2461) (250000, 5518) (500000, 10912) (1000000, 21573)
        };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | l | l | l | }
        \hline
            Кол-во букв    & Время (в мс) \\ \hline
            1000             & 32           \\
            50000            & 1001          \\
            100000           & 2461         \\
            250000           & 5518         \\
            500000           & 10912         \\
            1000000           & 21573         \\
        \hline
    \end{tabular}

    Таким образом, мы видим, что сложность данного алгоритма - $n^2$.

    Ниже приведен тест времени работы алгоритма декодирования. По оси $X$ — количество 
    троек, по оси $Y$ — время выполнения алгоритма в мс (меньше 
    — лучше).
    
    \begin{tikzpicture}
        \begin{axis} [
            ymin = 0
        ]
        \addplot coordinates {
            (1000,34) (1000,253) (100000,2847) (1000000, 22470)
        };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | l | l | l | }
        \hline
            Кол-во букв    & Время (в мс) \\ \hline
            1000             & 34           \\
            1000            & 253          \\
            100000           & 2847         \\
            1000000           & 22470         \\
        \hline
    \end{tabular}

    Таким образом, мы видим, что сложность данного алгоритма - $n$.

    \subsection*{Выводы}

    В результате проведенной лабораторной работы я познакомился с таким алгоритмом, как LZ77 и научился его реализовывать.
    В данной лабораторной была разработана лишь наивная реализация, с использованием суффиксного дерева можно было бы реализовать алгоритм
    с квадратичной сложностью, однако такой алгоритм был бы гораздо сложнее в реализации.

\end{document}